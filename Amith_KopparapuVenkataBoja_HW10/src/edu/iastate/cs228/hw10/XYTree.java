package edu.iastate.cs228.hw10;/** * A class that implements an xy-tree. *  * @author * Amith Kopparapu Venkata Boja *  *  *  * NOTEs and REQUIREMENTs: *  * 0. Put your Firstname and Lastname after above empty author tag.  * Make sure that in both cases the first letter is uppercase and  * all others are composed of lowercase letters. *  * 1. You are allowed to create and use your own private helper  * methods. If you are introducing your own helper methods those * need to be private ONLY and properly documented as per Javadoc  * style. Provided constructors/methods declarations cannot be changed. *  * 2. No additional data fields can be introduced in the class below. * Or any other class provided as part of this HW. You are not allowed  * to change the case of the already existing data fields, or rename those. *  * 3. No custom classes of your own can be introduced or used.  *  * 4. Import statements are not allowed.  *  * 5. Fully qualified class names usage is not allowed. Exception is  * for levelOrderTraverse method ONLY, where you are allowed to use  * ONLY java.util.LinkedList class. *  * 6. You are allowed to reuse any part of the provided source codes  * or shown under lecture notes section of Canvas, which do not violate  * any of the requirements. *  * 7. If you have any additional questions PLEASE ask on Piazza Q/A  * platform, however, before posting a question PLEASE, first, search * the Q/A platform to see if the same question was not already asked  * and answered. PLEASE setup your notifications for both Canvas and  * Piazza so that you are updated, immediately, whenever there are any  * changes happen either on Canvas or Piazza Q/A platform. *  * 8. You need to provide implementation to all methods which have a  * comment //TODO in their body. In this HW there 3 of those, i.e., * addPoint, contains, and leverlOrderTraverse. For all of these methods  * there is no need to provide comments. Same, i.e., no comments, applies * also for all provided classes/interfaces, including their  * constructors/methods which you are not required to implement as part  * of this HW.    *  * 9.You can assume that x and y values of every Point will always be * int values. *  *  */public class XYTree<T extends java.awt.Point> implements TreeInterface<T>{  private BinaryNode<T> root;  public XYTree()  {	root = null;  }  public XYTree(T rootData)  {	if (rootData != null)	  root = new BinaryNode<>(rootData);	else	  throw new IllegalArgumentException();  }  public void addAllPoints(T[] entries)  {	if (entries == null || entries.length == 0)	  throw new IllegalArgumentException();	for (T t : entries)	  addPoint(t);  }  /**   *   * Adds a new point into the xy-tree if it does not    * exist in this tree. Check an example under Canvas.   * Also, check the comment of levelOrderTraverse.   *    */  public void addPoint(T anEntry)  {	if (anEntry == null)	  throw new IllegalArgumentException();    	if(isEmpty()) {		root=new BinaryNode<T>(anEntry);	}else {		java.awt.Point p=(java.awt.Point) anEntry;		BinaryNode<T> n =root;		int height=0;		while(!n.getData().equals(anEntry)) {			if(height%2==0 && n.getData().getX()>=p.getX()) {				if(!n.hasLeftChild()) {					n.setLeftChild(new BinaryNode<T>(anEntry));					break;				}				n=n.getLeftChild();			}else if(height%2!=0 && n.getData().getY()>=p.getY()) {				if(!n.hasLeftChild()) {					n.setLeftChild(new BinaryNode<T>(anEntry));					break;				}				n=n.getLeftChild();			}else {				if(!n.hasRightChild()) {					n.setRightChild(new BinaryNode<T>(anEntry));					break;				}				n=n.getRightChild();			}			height++;		}	}  }  /**   * Returns true if a point exists in this tree,    * otherwise false.   *    */  public boolean contains(T anEntry)  {	if (anEntry == null)	  throw new IllegalArgumentException();	String str="(" + (int)anEntry.getX() + ", " + (int)anEntry.getY()+ ")";	return levelOrderTraverse().contains(str);  }  /**   * Returns a list of points in level-order traversal.    * In this method you are allowed to use    * java.util.LinkedList class.   *    *    * For example,   *    * XYTree<Point> xy = new XYTree<>();    *    * xy.addAllPoints(new Point[]{   * 	new Point(5, 3),    *    new Point(5, 2),    *    new Point(10, 7),    *    new Point(9, 1),    *    new Point(6, 8),    *    new Point(6, 8),    *    new Point(10, 1)   * });   * System.out.println(xy.levelOrderTraverse());   *    * would print   *    * [(5, 3), (5, 2), (10, 7), (9, 1), (6, 8), (10, 1)]   *    */  public java.util.LinkedList<String> levelOrderTraverse()  {	java.util.LinkedList<String> l=new java.util.LinkedList<String>();  	java.util.LinkedList<BinaryNode<T>> list = new java.util.LinkedList<>();	BinaryNode<T> currentNode = null;	list.addLast(root);	while (!list.isEmpty()) {		currentNode = list.pop();		if (currentNode.hasLeftChild()) {			list.addLast(currentNode.getLeftChild());		}		if (currentNode.hasRightChild()) {			list.addLast(currentNode.getRightChild());		}		l.add("("+(int)currentNode.getData().getX()+", "+(int)currentNode.getData().getY()+")");	}	return l;  }  @Override  @SuppressWarnings("unchecked")  public T getRootData()  {	if (isEmpty())	  throw new RuntimeException("Empty Tree!");	else	  return (T) root.getData().clone();  }  @Override  public boolean isEmpty()  {	return root == null;  }  @Override  public void clear()  {	root = null;  }  @Override  public int getHeight()  {	return root.getHeight();  }  @Override  public int getNumberOfNodes()  {	return root.getNumberOfNodes();  }}